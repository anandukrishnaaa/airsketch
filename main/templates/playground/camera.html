{% extends "base.html" %}
{% block content %}
    <video id="videoElement" width="640" height="480" autoplay hidden=true>
    </video>
    <canvas id="canvasElement" width="640" height="480"></canvas>
    <canvas id="drawCanvas" width="640" height="480"></canvas>
    <button id="toggleButton">Toggle Camera</button>
    <script defer>
        const video = document.getElementById('videoElement');
        const canvas = document.getElementById('canvasElement');
        const drawCanvas = document.getElementById('drawCanvas');
        const drawCtx = drawCanvas.getContext('2d');
        const toggleButton = document.getElementById('toggleButton');
        const ctx = canvas.getContext('2d');
        let isCameraOn = false;
        let model;
        // Keep track of previous hand position
let prevHandX = null;
let prevHandY = null;
        
        const modelParams = {
            flipHorizontal: true,
            maxNumBoxes: 1,
            iouThreshold: 0.5,
            scoreThreshold: 0.7,
        };
        
        const statusMessage = document.createElement('div');
        statusMessage.textContent = 'Loading model...';
        document.body.appendChild(statusMessage);
        
        toggleButton.disabled = true;
        
        async function loadHandTrackModel() {
            try {
                model = await handTrack.load(modelParams);
                console.log(model.getModelParameters()); // returns model parameters
                statusMessage.textContent = 'Model loaded';
                toggleButton.disabled = false;
                displayMessage('Camera turned off/unavailable');
            } catch (error) {
                console.error('Error loading model:', error);
                statusMessage.textContent = 'Error loading model';
            }
        }
        
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: {} });
                video.srcObject = stream;
                isCameraOn = true;
                await handTrack.startVideo(video);
                runDetection();
                clearCanvas();
            } catch (error) {
                console.error('Error accessing camera:', error);
            }
        }
        
        async function runDetection() {
            try {
                const predictions = await model.detect(video);
                model.renderPredictions(predictions, canvas, ctx, video);
// Inside the runDetection function, update the initial hand position
if (prevHandX === null && prevHandY === null && predictions.length > 0) {
    const initialPrediction = predictions.find(prediction => prediction.label === 'point' && prediction.score > 0.8);
    if (initialPrediction) {
        prevHandX = initialPrediction.bbox[0] + initialPrediction.bbox[2] / 2;
        prevHandY = initialPrediction.bbox[1] + initialPrediction.bbox[3] / 2;
    }
}
                // prediction.score can be 0-1
                // Draw lines between consecutive hand positions
predictions.forEach(prediction => {
    if (prediction.label === 'point' && prediction.score > 0.8) {
        const handX = prediction.bbox[0] + prediction.bbox[2] / 2;
        const handY = prediction.bbox[1] + prediction.bbox[3] / 2;

        // Draw a line from previous position to current position
        drawCtx.strokeStyle = 'blue';
        drawCtx.lineWidth = 2;
        drawCtx.beginPath();
        drawCtx.moveTo(prevHandX, prevHandY);
        drawCtx.lineTo(handX, handY);
        drawCtx.stroke();

        // Update previous hand position
        prevHandX = handX;
        prevHandY = handY;
    }
});

// Detect hand gesture labeled as "closed" and clear canvas
predictions.forEach(prediction => {
    if (prediction.label === 'closed' && prediction.score > 0.8) {
        clearDrawingCanvas();
    }
});

// Function to clear the drawingCanvas
function clearDrawingCanvas() {
    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
}

                if (isCameraOn) {
                    requestAnimationFrame(runDetection);
                }
            } catch (error) {
                console.error('Error detecting:', error);
            }
        }
        
        function toggleCamera() {
            if (isCameraOn) {
                stopCamera();
                displayMessage('Camera turned off/unavailable');
            } else {
                startCamera();
                toggleButton.textContent = 'Stop Camera';
                clearCanvas();
            }
        }
        
        function stopCamera() {
            video.srcObject.getTracks().forEach(track => track.stop());
            video.srcObject = null;
            isCameraOn = false;
            toggleButton.textContent = 'Start Camera';
        }
        
        function displayMessage(message) {
            clearCanvas();
            ctx.font = '20px Arial';
            ctx.fillStyle = 'red';
            ctx.fillText(message, 20, 50);
        }
        
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        toggleButton.addEventListener('click', toggleCamera);
        
        loadHandTrackModel();
        
    </script>
{% endblock content %}
