{% load static %}
{% block content %}
    <script src="{% static 'js/handtrack.min.js' %}" type="text/javascript"></script>
    <style>
canvas {
    border: 1px solid black;
}

    </style>
    <details>
        <summary>Instructions</summary>
        <p>Draw by using the point action, erase by using closed action.</p>
    </details>
    <video id="videoElement" width="640" height="480" autoplay hidden=true>
    </video>
    <canvas id="canvasElement" width="640" height="480"></canvas>
    <canvas id="drawCanvas" width="640" height="480"></canvas>
    <button id="toggleButton">Toggle Camera</button>
    {% csrf_token %}
    <script defer>
        const video = document.getElementById('videoElement');
        const canvas = document.getElementById('canvasElement');
        const drawCanvas = document.getElementById('drawCanvas');
        const drawCtx = drawCanvas.getContext('2d');
        const toggleButton = document.getElementById('toggleButton');
        const ctx = canvas.getContext('2d');
        const csrfInput = document.querySelector('input[name="csrfmiddlewaretoken"]');
        let isCameraOn = false;
        let model;
        let handClosedTime = 0;
        let prevHandX = null;
        let prevHandY = null;
        let shapes = [];
        let intervalId = null;
let isDrawing = false;

        
        const modelParams = {
            flipHorizontal: true,
            maxNumBoxes: 1,
            iouThreshold: 0.5,
            scoreThreshold: 0.6,
        };
        
        const statusMessage = document.createElement('div');
        statusMessage.textContent = 'Loading model...';
        document.body.appendChild(statusMessage);
        toggleButton.disabled = true;
        
        async function loadHandTrackModel() {
            try {
                model = await handTrack.load(modelParams);
                statusMessage.textContent = 'Model loaded';
                toggleButton.disabled = false;
                displayMessage('Camera turned off/unavailable');
            } catch (error) {
                console.error('Error loading model:', error);
                statusMessage.textContent = 'Error loading model';
            }
        }
        
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: {} });
                video.srcObject = stream;
                isCameraOn = true;
                await handTrack.startVideo(video);
                runDetection();
                clearCanvas();
            } catch (error) {
                console.error('Error accessing camera:', error);
            }
        }
        
        async function runDetection() {
            try {
                const predictions = await model.detect(video);
                model.renderPredictions(predictions, canvas, ctx, video);
        
                predictions.forEach(prediction => {
                    if (prediction.label === 'point' && prediction.score > 0.8) {
                        handlePointPrediction(prediction);
                    }
                });
        
                handleHandGesture(predictions);
        
                if (isCameraOn) {
                    requestAnimationFrame(runDetection);
                }
            } catch (error) {
                console.error('Error detecting:', error);
            }
        }
        
        function handlePointPrediction(prediction) {
            const handX = prediction.bbox[0] + prediction.bbox[2] / 2;
            const handY = prediction.bbox[1] + prediction.bbox[3] / 2;
        
            if (prevHandX !== null && prevHandY !== null) {
                drawLine(prevHandX, prevHandY, handX, handY);
            }
        
            prevHandX = handX;
            prevHandY = handY;
            storeDrawingData(handX, handY);
        }
        
        function handleHandGesture(predictions) {
            const closedPrediction = predictions.find(prediction => prediction.label === 'closed' && prediction.score > 0.8);
            if (closedPrediction) {
                handClosedTime += 1;
                if (handClosedTime >= 20) {
                    clearDrawingCanvas();
                }
            } else {
                handClosedTime = 0;
            }
        }
        
        function drawLine(startX, startY, endX, endY) {
            drawCtx.strokeStyle = 'blue';
            drawCtx.lineWidth = 2;
            drawCtx.beginPath();
            drawCtx.moveTo(startX, startY);
            drawCtx.lineTo(endX, endY);
            drawCtx.stroke();
        }
        
        function storeDrawingData(x, y) {
            // Initialize a new shape if it's the first point
            if (shapes.length === 0 || shapes[shapes.length - 1][2].length === 0) {
                shapes.push([[x], [y], [Date.now()]]);
            } else {
                // Add the new point to the current shape
                shapes[shapes.length - 1][0].push(x);
                shapes[shapes.length - 1][1].push(y);
                shapes[shapes.length - 1][2].push(Date.now() - shapes[shapes.length - 1][2][0]);
            }
            // Start the interval if it's not already running
    if (!isDrawing) {
        isDrawing = true;
        intervalId = setInterval(sendDataToCanvas, 5000); // 5 seconds interval
    }
        }
        
        
        function sendDataToCanvas() {
            const canvasData = {
                canvasWidth: drawCanvas.width,
                canvasHeight: drawCanvas.height,
                shapes: shapes
            };
        
            console.log('Data sent to server:', canvasData);
        
            fetch('http://127.0.0.1:8000/api_canvas/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfInput.value
                },
                body: JSON.stringify(canvasData)
            })
            .then(response => response.json())
            .then(responseData => {
                console.log('Response from server:', responseData);
            })
            .catch(error => {
                console.error('Error sending data:', error);
            });
        }
        
        function clearDrawingCanvas() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            shapes = []; // Clear the shapes array
            handClosedTime = 0;
             // Stop the interval if it's running
    if (isDrawing) {
        clearInterval(intervalId);
        intervalId = null; // Reset the interval ID
        isDrawing = false;
    }
        }
        
        
        function toggleCamera() {
            if (isCameraOn) {
                stopCamera();
                displayMessage('Camera turned off/unavailable');
            } else {
                startCamera();
                toggleButton.textContent = 'Stop Camera';
                clearCanvas();
            }
        }
        
        function stopCamera() {
            video.srcObject.getTracks().forEach(track => track.stop());
            video.srcObject = null;
            isCameraOn = false;
            toggleButton.textContent = 'Start Camera';
        }
        
        function displayMessage(message) {
            clearCanvas();
            ctx.font = '20px Arial';
            ctx.fillStyle = 'red';
            ctx.fillText(message, 20, 50);
        }
        
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        toggleButton.addEventListener('click', toggleCamera);
        
        loadHandTrackModel();

    </script>
{% endblock content %}
