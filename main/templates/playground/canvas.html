{% load static %}
{% block content %}
    <script type="application/javascript"
            src="{% static 'js/handtrack.min.js' %}"></script>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
    <details>
        <summary>Instructions</summary>
        <p>Draw by using the point action, erase by using closed action.</p>
    </details>
    <video id="videoElement" width="640" height="480" autoplay hidden=true>
    </video>
    <canvas id="canvasElement" width="640" height="480"></canvas>
    <canvas id="drawCanvas" width="640" height="480"></canvas>
    <button id="toggleButton">Draw using camera</button>
    <button id="clearButton">Clear Canvas</button>
    <button id="mouseDrawToggle">Draw using mouse</button>
    <p id="inputMethodMessage">Select an input method</p>
    {% csrf_token %}
    <input type="hidden" name="uuid" value="{{ uuid }}">
    <script defer>
        const video = document.getElementById('videoElement');
        const canvas = document.getElementById('canvasElement');
        const drawCanvas = document.getElementById('drawCanvas');
        const drawCtx = drawCanvas.getContext('2d');
        const toggleButton = document.getElementById('toggleButton');
        const clearButton = document.getElementById('clearButton');
        const mouseDrawToggle = document.getElementById('mouseDrawToggle');
        const ctx = canvas.getContext('2d');
        const csrfInput = document.querySelector('input[name="csrfmiddlewaretoken"]');
        const uuidInput = document.querySelector('input[name="uuid"]');
        let isCameraOn = false;
        let model;
        let handClosedTime = 0;
        let prevHandX = null;
        let prevHandY = null;
        let shapes = [];
        let intervalId = null;
        let isDrawing = false;
        let isMouseDrawing = false;
        let ws; // WebSocket object
        const uuid = uuidInput.value;
        console.log("UUID:", uuid);
        
        // Initialize canvas WebSocket connection
        ws = new WebSocket(`ws://127.0.0.1:3000/ws/canvas/${uuid}`);
        
        ws.onopen = function(event) {
            console.log('canvas WebSocket connection opened');
        };
        
        ws.onclose = function(event) {
            console.log('canvas WebSocket connection closed');
            // Reconnect logic can be implemented here
        };
        
        ws.onerror = function(error) {
            console.error('canvas WebSocket error:', error);
        };
        
        const modelParams = {
            flipHorizontal: true,
            maxNumBoxes: 1,
            iouThreshold: 0.5,
            scoreThreshold: 0.6,
        };
        
        const statusMessage = document.createElement('div');
        statusMessage.textContent = 'Loading model...';
        document.body.appendChild(statusMessage);
        toggleButton.disabled = true;
        
        async function loadHandTrackModel() {
            try {
                model = await handTrack.load(modelParams);
                statusMessage.textContent = 'Model loaded';
                toggleButton.disabled = false;
                displayMessage('Camera turned off/unavailable');
            } catch (error) {
                console.error('Loading model:', error);
                statusMessage.textContent = 'Loading model';
            }
        }
        
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: {} });
                video.srcObject = stream;
                isCameraOn = true;
                await handTrack.startVideo(video);
                runDetection();
                clearCanvas();
            } catch (error) {
                console.error('Error accessing camera:', error);
                displayMessage('Error accessing camera');
            }
        }
        
        async function runDetection() {
            try {
                const predictions = await model.detect(video);
                model.renderPredictions(predictions, canvas, ctx, video);
        
                predictions.forEach(prediction => {
                    if (prediction.label === 'open' && prediction.score > 0.8) {
                        handlePointPrediction(prediction);
                    }
                });
        
                handleHandGesture(predictions);
        
                if (isCameraOn) {
                    requestAnimationFrame(runDetection);
                }
            } catch (error) {
                console.error('Error detecting:', error);
            }
        }
        
        function handlePointPrediction(prediction) {
            const handX = prediction.bbox[0] + prediction.bbox[2] / 2;
            const handY = prediction.bbox[1] + prediction.bbox[3] / 2;
        
            if (prevHandX !== null && prevHandY !== null) {
                drawLine(prevHandX, prevHandY, handX, handY);
            }
        
            prevHandX = handX;
            prevHandY = handY;
            storeDrawingData(handX, handY);
        }
        
        function handleHandGesture(predictions) {
            const closedPrediction = predictions.find(prediction => prediction.label === 'closed' && prediction.score > 0.8);
            if (closedPrediction) {
                handClosedTime += 1;
                if (handClosedTime >= 20) {
                    clearDrawingCanvas();
                }
            } else {
                handClosedTime = 0;
            }
        }
        
        function drawLine(startX, startY, endX, endY) {
            drawCtx.strokeStyle = 'blue';
            drawCtx.lineWidth = 2;
            drawCtx.beginPath();
            drawCtx.moveTo(startX, startY);
            drawCtx.lineTo(endX, endY);
            drawCtx.stroke();
        }
        
        function storeDrawingData(x, y) {
            if (shapes.length === 0 || shapes[shapes.length - 1][2].length === 0) {
                shapes.push([[x], [y], [Date.now()]]);
            } else {
                shapes[shapes.length - 1][0].push(x);
                shapes[shapes.length - 1][1].push(y);
                shapes[shapes.length - 1][2].push(Date.now() - shapes[shapes.length - 1][2][0]);
            }
            if (!isDrawing) {
                isDrawing = true;
                intervalId = setInterval(sendDataToCanvas, 5000);
            }
        }
        
        function sendDataToCanvas() {
            const canvasData = {
                canvasWidth: drawCanvas.width,
                canvasHeight: drawCanvas.height,
                shapes: shapes
            };
        
            console.log('Data sent to server:', canvasData);
        
            ws.send(JSON.stringify(canvasData));
        }
        
        function clearDrawingCanvas() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            shapes = [];
            handClosedTime = 0;
            if (isDrawing) {
                clearInterval(intervalId);
                intervalId = null;
                isDrawing = false;
            }
        }
        
        clearButton.addEventListener('click', clearDrawingCanvas);
        
        function toggleCamera() {
            if (isCameraOn) {
                stopCamera();
                displayMessage('Camera turned off/unavailable');
            } else {
                updateInputMethodMessage('hand')
                startCamera();
                toggleButton.textContent = 'Stop drawing using Camera';
                clearCanvas();
            }
        }
        
        function stopCamera() {
            video.srcObject.getTracks().forEach(track => track.stop());
            video.srcObject = null;
            isCameraOn = false;
            toggleButton.textContent = 'Start Camera';
        }
        
        function displayMessage(message) {
            clearCanvas();
            ctx.font = '20px Arial';
            ctx.fillStyle = 'red';
            ctx.fillText(message, 20, 50);
        }
        
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        toggleButton.addEventListener('click', toggleCamera);
        
        // Mouse drawing functionality
        mouseDrawToggle.addEventListener('click', function() {
            isMouseDrawing = !isMouseDrawing;
            this.textContent = isMouseDrawing ? 'Stop Drawing with Mouse' : 'Draw using mouse';
            updateInputMethodMessage(isMouseDrawing ? 'mouse' : 'hand'); // Update the message based on the current state
            if (!isMouseDrawing) stopDrawing(); // Stop drawing with mouse if toggle is turned off
        });
        
        // Add event listener for mouse down directly on the drawCanvas
        drawCanvas.addEventListener('mousedown', startDrawing);
        
        // Remove unnecessary event listener when drawing stops
        function stopDrawing() {
            if (!isMouseDrawing) return;
            drawCanvas.removeEventListener('mousemove', draw);
            updateInputMethodMessage('hand'); // Update the message when stopping drawing with mouse
        }
        
        // Update startDrawing function to handle mouse input
        function startDrawing(event) {
            if (!isMouseDrawing) return;
            drawCanvas.addEventListener('mousemove', draw);
            const { offsetX, offsetY } = event;
            drawCtx.beginPath();
            drawCtx.moveTo(offsetX, offsetY);
            storeDrawingData(offsetX, offsetY);
            updateInputMethodMessage('mouse'); // Update the message when starting to draw with mouse
        }
        
        // Update draw function to handle mouse input
        function draw(event) {
            if (!isMouseDrawing) return;
            const endX = event.clientX - drawCanvas.getBoundingClientRect().left;
            const endY = event.clientY - drawCanvas.getBoundingClientRect().top;
            drawCtx.lineTo(endX, endY);
            drawCtx.stroke();
        
            // Store the drawing data in the shapes array
            if (shapes.length === 0 || shapes[shapes.length - 1][2].length === 0) {
                shapes.push([[endX], [endY], [Date.now()]]);
            } else {
                shapes[shapes.length - 1][0].push(endX);
                shapes[shapes.length - 1][1].push(endY);
                shapes[shapes.length - 1][2].push(Date.now() - shapes[shapes.length - 1][2][0]);
            }
        }
        
        document.addEventListener('mouseup', stopDrawing);
        
        // Function to update the input method message
        function updateInputMethodMessage(method) {
            const messageElement = document.getElementById('inputMethodMessage');
            messageElement.textContent = `Drawing with: ${method}`;
        }
        
        loadHandTrackModel();
    </script>
{% endblock content %}
